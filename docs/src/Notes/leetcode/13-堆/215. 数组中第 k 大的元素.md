---
题目地址: https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcod-2/?envType=study-plan-v2&envId=top-100-liked
难度: 中等
---
难绷，我偷懒用了三行随便写了；实际上应该用 桶排序/建堆，接下来分别把他们拿出来总结下：

## 桶排序  

https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/307351/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcod-2/comments/2216100/

看题设，-10000 到 10000，没要求空间复杂度，

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int[] buckets = new int[20001];
        for (int i = 0; i < nums.length; i++) {
            buckets[nums[i] + 10000]++;
        }
        for (int i = 20000; i >= 0; i--) {
            k = k - buckets[i];
            if (k <= 0) {
                return i - 10000;
            }
        }
        return 0;
    }
}
```

这段代码使用了一种类似计数排序（属于桶排序的一种）的方法来高效地找到数组中第k大的元素。以下是详细的解释：

### 代码思路
1. **统计元素出现次数**：创建一个足够大的数组`buckets`，将原数组中的每个元素映射到`buckets`的特定位置，并统计出现次数。
2. **逆序查找第k大元素**：从最大的可能值开始逆序遍历`buckets`，累加出现次数，直到找到第k大的元素。

### 关键步骤解析
1. **初始化桶数组**：
   ```java
   int[] buckets = new int[20001];
   ```
   这里假设原数组`nums`中的元素范围是`[-10000, 10000]`。通过`nums[i] + 10000`将元素映射到`0~20000`的非负索引，解决负数问题。

2. **填充桶**：
   ```java
   for (int i = 0; i < nums.length; i++) {
       buckets[nums[i] + 10000]++;
   }
   ```
   遍历原数组，每个元素对应的桶计数加1。例如，元素`3`会映射到`10003`的位置，`-5`映射到`9995`的位置。

3. **逆序查找第k大**：
   ```java
   for (int i = 20000; i >= 0; i--) {
       k = k - buckets[i];
       if (k <= 0) {
           return i - 10000; // 还原原始数值
       }
   }
   ```
   - 从最大值（`20000`对应原数`10000`）开始倒序遍历。
   - 每次减去当前桶的计数，当`k ≤ 0`时，说明当前桶对应的元素即为第k大的元素。
   - `i - 10000`将索引还原为原始数值。

### 示例说明
假设`nums = [3, 2, 1, 5, 5, 4]`，`k = 2`：
1. 统计后，`buckets`中`5`出现2次，`4`、`3`、`2`、`1`各1次。
2. 逆序遍历时，先遇到`5`（计数2），`k -= 2`后变为0，满足条件，返回`5`。这就是第二大的元素（因为最大是5，第二大也是5）。

### 复杂度分析
- **时间复杂度**：O(n + m)，其中n是数组长度，m是桶的数量（20001）。两次线性遍历，非常高效。
- **空间复杂度**：O(m)，用于存储桶的计数。

### 适用场景
- 元素范围有限（如题目给定范围）时效率极高。
- 若元素范围极大，此方法可能因空间消耗过大而不适用，需改用其他方法（如快速选择）。

这种方法巧妙地利用计数排序的思想，在O(n)时间内解决问题，是处理受限范围数据的经典方案。

## 大顶堆

堆，都是完全二叉树，有如下的性质：

索引为 `i` 的节点的左子节点： `2 * i + 1`；右子节点： `2 * i + 2`
索引为 `j` 的节点的父节点计算法：`(j-1)/2` 注意要减一！


