---
aliases:
  - MAC
tags:
  - 消息鉴别码
  - MAC
来自于: "[[6.2_hash和MAC.pdf]]"
---
# 第1部分 概述  
* 定义在(K,M,T)上
	* 密钥$k \in K$  
	* 消息$m \in M$  
	* MAC值 $t\in T,t=S(k,m)$  ，S为认证函数
	* oracle：MAC设备
* 密钥+**任意长度**消息=**固定长度**认证码  
## 1.1 攻击
* 按照攻击目的分：
	* 密钥恢复攻击：目的是找到k  
	* 伪造攻击：未知密钥的情况下，伪造（消息，认证码）对
		* 选择性伪造：自由伪造
		* 存在性伪造：只能伪造他不能选择的消息
* 按照攻击种类分：
	* 被动攻击
		* 已知消息攻击：窃听得知
	* 主动攻击：通过选取一些消息，发送给oracle得到对应的认证码  
		* 非自适应选择消息攻击：使用oracle之前，已经选定所测试的消息
		* 自适应选择消息攻击：根据输出来选择下次发给oracle的消息  
# 第2部分 构造  
## 2.1 CBC-MAC  
* [[4 现代密码学第四讲：分组密码3.pdf#page=55&selection=114,0,115,2|CBC模式]]  
### 2.1.1 两种攻击  
*不考虑填充*  
* cut and paste：假定t1=Ek(D1)，则t1是两个分组的消息(D1||D2 )的一个 合法认证值，其中，D2= D1 ⊕t1。  
	* 不知道 K  
	* 明文1 与 密文1 异或后 作为 明文2  
	* 那么 第二组与密钥K一同加密的是 密文1异或密文1异或明文1等于明文1，则密文2等于密文1  
* [[6.2_hash和MAC.pdf#page=13&selection=54,0,58,0|伪造某消息D的合法MAC]]    
	* 与上面这种攻击的区别仅在于D2=D⊕t1
### 2.1.2 三种填充方法  
1. 右边全填充 0  
2. 右边先填充一个1，再填充 0  
3. 先在右边填充 0，再在左边填充一个组，包含原数据的比特长度，不够的左填 0
### 2.1.3 构造流程  
1. 填充数据  
2. CBC加密  
3. 对最终结果进行处理/截断
## 2.2 HMAC  
### 2.2.1 构造流程  
* 元素介绍：
	* H：哈希函数  
	* K：密钥  
	* B：消息分块的字节长度  
	* L：消息摘要的长度  
	* ipad：36 36 36 36...重复B次，为0x36  
	* opad：5C 5C 5C 5C...重复B次，为0x5C
* $MAC=H((K \oplus opad)||H(K \oplus ipad||text))$ 
* ![[消息鉴别码.png]]
