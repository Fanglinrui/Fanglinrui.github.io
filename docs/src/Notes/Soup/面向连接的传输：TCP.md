---
tags:
  - TCP
  - 流量控制
  - 拥塞控制
来自于: "[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=170&selection=14,0,16,3|计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library), page 170]]"
相关知识点: "[[可靠的数据传输]]"
updateTime: 2025-04-11 16:48
---
# 1 TCP连接  
## 1.1 三次握手  
* 握手，也就是“面向连接”的原因  
* 前两次握手没有有效载荷，第三次则有（有效载荷：应用层数据）  
## 1.2 MSS（最大报文段长度）  
* MSS + TCP/IP首部（通常 40 字节）= MTU（最大传输单元/最大链路层帧长度（通常为1500BYTE））
* 由上一条，MSS的典型长度为 1460 B  
更具体的，参见[[#6 TCP连接的建立和拆除]]
# 2 TCP 报文段结构  
* 为了实现其功能，肯定要有[[可靠的数据传输#RDT的机制和用途]]  
* [[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=172&selection=95,0,97,5|图在这]]
* 首部：共20B  
	* 4B seq-field， 4B ack-field  
	* 2B 接收窗口，表示**愿意接受的字节数**，用于流量控制  
	* 4b首部长度，6b标志——注意这里是比特不是字节  
	* 剩下的是保留未用4b，检验和2B，紧急数据指针2B  
* **注意：一个报文段的序号就是该报文段*数据字段*首字节的序号**  
* ACK采用了累积确认(cumulative acknowledgment)  
* #捎带确认 ：对客户到服务器的数据的确认被装载在服务器到客户的数据的报文段当中  
# 3 往返时间估计与超时  
[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=175&selection=286,0,286,10|原文在此！]]
## 3.1背景：  
TCP也采用超时重传机制来处理丢失问题，那么这个超时的时间间隔应该如何设置呢？  
**首先，我们知道的是它肯定要大于RTT** ，具体如何，就需要来进行探讨了  
## 3.2 估计往返时间  
给出公式  
EstimatedRTT = (1-α) · EstimatedRTT + α · SampleRTT  
* [[3传输层.pdf#page=85&selection=44,0,54,1|注意，这里的α与计算机网络课上的1-α相同  ]]  
* 这种算法被称为 **指数加权移动平均**  
然后是计算SampleRTT偏离EstimatedRTT程度：  
DevRTT=(1-β) · DevRTT+β · |SampleRTT - EstimatedRtt|  
* β值推荐为0.25  
## 3.3 结论  
TimeoutInterval = EstimatedRTT + 4 · DevRTT  

# 4 可靠数据传输  
* 采用的是累积ACK
* 不采用NAK
* 与超时重传有关的3个主要事件  
	* 定时器超时
		#超时间隔加倍
		大多数TCP实现中，**在定时器超时时**，超时间隔并不是采用[[面向连接的传输：TCP#3.3]]中的值，而是直接把上一次的值翻倍，另外两个采用#3.3中的值
	* 从上层应用程序接收数据  
	* 收到ACK  
* #快速重传 ——定时器过期前就重新发送
	* 什么时候使用：收到三个冗余ACK  
		* 冗余ACK产生的原因：接收方发现收到的数据产生间隔，故对最后收到的按序字节数据进行重复确认。   
	* [[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=181&selection=22,0,28,9|哪些动作会产生ACK？]]  
		* 期望的报文段到达——延迟ACK  
		* 期待的报文段到达，上一个到达的报文段还在等待ACK——立刻发送累积ACK，确认两个报文段  
		* 序号大于期望的报文段，这表明出现间隔——立刻发送冗余ACK  
		* 能部分或完全填充接收数据间隔的报文段到达——倘若该报文段起始于间隔的低端，那么立刻发送ACK  
* TCP是GBN还是SR？
	* TCP更像GBN，因为是累积确认；
	* 但同时，它也缓存失序片段  
	* [[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=182&selection=99,0,110,0|还有一种方案]] ，这使得TCP成为GBN和SR的混合体
# 5 #流量控制    
* 注意对比与拥塞控制的区别，二者都是对发送方进行遏制，不过流量控制是为了使双方速率匹配，而拥塞控制是因为IP网络*拥塞*  
## 5.1 定义变量  
* LastByteRead:接收方上的应用进程从缓存读出的数据流的最后一个字节的编号。
* LastByteRcvd:从网络中到达的并且已放入接收方接收缓存中的数据流的最后一个字节的编号。
* 由于TCP不允许已分配的缓存溢出，故最后收到的与最后读取的之间的差值必须在Buffer内  
* rwnd：接收窗口——缓存可用空间，是动态的    
* 一个很好的图：
![[面向连接的传输：TCP.png]]  
## 5.2 具体机理  
出乎意料的简单，接收方把rwnd**的值**放进[[面向连接的传输：TCP#2 TCP 报文段结构|这里的接收窗口]]  ，用来通知发送方
* rwnd这个变量由接收方维护，发送方也会提取这个值
* 一开始，rwnd = RcvBuffer  
* 发送方只用确保：$LastByteSent-LastByteAcked \le rwnd$  
* 当接收方窗口为0时，发送方发送只有一个字节数据的报文段，接收方确认。缓存清空，保证rwnd时非0的  
# 6 TCP连接的建立和拆除  
## 6.1 建立连接  
1. **客户**发送SYN报文段，并提供seq = client_isn(初始序号)，不包含应用层数据  
2. **服务器**提取SYN报文段，分配TCP缓存和变量，seq = server_isn，ack = client **+1**  ，也不包含数据；这个报文段也称SYNACK报文段  
3. **客户** 收到SYNACK报文段后，分配缓存和变量，发送确认报文段，seq = client +1 ,ack = server_isn **+1**，这里可以携带数据  
## 6.2 结束连接  
1. 第1步：主机1发送FIN报文段  
2. 第2步：主机2返回ACK报文段， 主机1-2方向的连接被关闭， 资源被释放  
3. 第3步：主机2发送FIN报文段  
4. 第4步：主机1返回ACK报文段， 主机2-1方向的资源被释放， 整个连接关闭  
## 6.3 其它需要注意的问题  
1. 可以看出，SYN和FIN均消耗1字节序号
2. cookie：[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=186&selection=281,0,283,4|计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library), page 186]]

# 7 #拥塞控制  
## 7.1 综述   
* 分组重传作为网络拥塞的征兆  
* 发送方想以过高的速率发送数据  
* 需要机制来遏制发送方  
## 7.2 拥塞产生原因的递进讨论  
来自[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=188&selection=502,0,502,6|计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library), page 188]]
### 7.2.1 两个发送方和一台具有无穷大缓存的路由器  
* 设共享的输出链路容量为*R*  
* 在这种情况下，有两种情况：
	* 发送速率在0~R/2时，接收方吞吐量等于发送方的发送速率  
	* 发送速率大于R/2时，吞吐量只能维持在R/2
	* 这是由于共享链路造成的，无论AB怎么再提高都不会改变。
* ![[面向连接的传输：TCP-1.png]]  
* 观察这个图，可以发现，当发送速率接近R/2时，时延变得无限大
* **巨大的代价：** 分组的到达速率接近链路容量时，经历巨大的排队时延。

### 7.2.2  两个发送方和一台具有有限缓存的路由器  
![[面向连接的传输：TCP-2.png]]  
* 代价一：发送方必须重传以补偿因为缓存溢出而被丢弃的分组
而如果发送方提前重传在队列中还没有丢失的分组，这种情况下又会有另一种代价：  
* 即发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本  
### 7.2.3 四个发送方和具有有限缓存的多台路由器以及多跳路径  
*具体情况[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=191&selection=302,0,308,22|参考原文]]，这里仅给出代价*  
* 当一个分组沿一条路径被丢弃时，每个**上游**路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了 
## 7.3 两种主要的拥塞控制方法  
*区分标准：网络层是否为运输层拥塞控制提供了显示帮助*  
* 没有提供显式帮助：**端到端拥塞控制** 
	* 端系统必须通过分组丢失和时延来推断网络中存在的拥塞  
* 反之：**网络辅助的拥塞控制**  
	* 两种方法：
		* 直接网络反馈：路由器发给发送方，采用阻塞分组  
		* 经由接收方地网络反馈：路由器*标记或更新* 发送方流向接收方地分组中地某个字段，接收方接收到这种分组后，向发送方同志拥塞；这种情况之少经过一个完整RTT
* 默认因特网版本的IP和TCP采用**第一种**，最近也*可以选择性地*实现第二种  
# 8 TCP拥塞控制  
* 因为IP层不向端系统提供显式地网络拥塞反馈，故TCP使用**端到端拥塞控制** ，参看[[#7.3 两种主要的拥塞控制方法]]  
* TCP 采用的方法是使 **发送方** 去感知网络拥塞程度从而限制其发送流量的速率  ，*那么*：
	* TCP发送方如何限制其发送流量的速率？  
	* TCP发送方如何感知网络拥塞程度？  
	* 发送方感知到拥塞后，通过何种算法来改变发送速率？
## 8.1 对三个问题的解答  
### 8.1.1 TCP发送方如何限制其发送流量的速率？
* *联动[[#5 流量控制]]* ，注意关键词：限制，流量  
	* TCP两端均有*一个接收缓存、一个发送缓存、几个变量（LastByteRead、rwnd)*
	* 发送方的拥塞控制机制额外跟踪一个变量，拥塞窗口(congestion window)——cwnd
	* 发送方要保证：$LastByteSent - LastByteAcked \le \min \{ cwnd, rwnd \}$  
	* 注意，这里有很多LastByteXXX, 注意区分，发送方和接收方是不同的
* **控制机理** 
	* 假设TCP接收缓存足够大  
	* 发送方发送速率为 cwnd/RTT Byte/s 
	* 通过调整cwnd，即可调整发送速率

### 8.1.2 TCP发送方如何感知网络拥塞程度？
* 丢包事件的定义：要么出现超时，要么收到来自接收方的3个冗余ACK  
* 拥塞时，会产生丢包事件，丢包事件使得发送方认为出现了拥塞  
* 一切正常时，发送方通过 **确认的到达** 来认定路径上一切正常，并依此来增加cwnd  
### 8.1.3 发送方感知到拥塞后，通过何种算法来改变发送速率？  
* *通过前两个问题，我们知道调整发送速率的关键在于调整 cwnd 的值，接下来讨论具体**怎么**去调整*  ，既使得网络不会拥塞，又能充分利用所有可用的带宽？  
* 原则如下：  
	* 丢包事件发生时降低发送方速率  
	* 确认报文段到达时增加速率  
	* 进行带宽探测；不断试探  
## 8.2 TCP拥塞控制算法 
[[计算机网络（原书第7版） 自顶向下方法 (James F. Kurose Keith W. R... (Z-Library).pdf#page=195&selection=337,0,341,6|在这有完全内容]]  
包括三个部分：
1. 慢启动  
	* 初期指数增长  
	* **超时**丢包事件发生，cwnd=1，阈值=拥塞值一半，重新开始慢启动  
		* 到达ssthresh（阈值）时，改为拥塞避免模式
	* **3个冗余ACK**时，快速恢复
1. 拥塞避免  
	* 拥塞避免发生时，cwnd 约为上次拥塞时的一半，这时每次cwnd + 1，此时为线性增长  
	* **结束条件**：
		* **超时**：同慢启动，cwnd=1,ssthresh变为新阻塞的一半  
		* **3个冗余ACK**：cwnd =cwnd/2 ,ssthresh 变为一半（相当于两个相等，那么进入线性增长），进入快速恢复
1. 快速恢复
	* 对于每个冗余ACK，增加cwnd，丢失报文段ACK到达时，降低cwnd，进入拥塞避免；超时时，同慢启动
前两者必须，第三个可选  
[[3传输层.pdf#page=104&selection=4,0,5,8|学校的讲解]] 中并没有涉及快速恢复。


