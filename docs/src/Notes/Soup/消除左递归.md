---
tags:
  - 编译原理
  - 语法分析
  - 左递归
  - 算法
参考: https://blog.csdn.net/weixin_44246009/article/details/107035944
updateTime: 2025-04-11 16:48
---
## 描述  
- 立即左递归：形如 𝐴 -> 𝐴𝛼 ，在这种情况下，假设给一个 A , 那么可以这个 A 可以动态地向左边延申  
- 比如： 𝐴 → 𝐴𝛼 | 𝛽 它生成以符号𝛽开头的句子，后面跟零个或更多的𝛼’s  
## 消除的原因  
- 自顶向下的分析无法处理左递归  
## 操作  
### 消除立即左递归
![[消除左递归-2.png]]  
- 就是把有本身的派生全放到新的里面，并把右半提前  
- 没有本身的派生直接提前，并加上新的
### 消除左递归  
![[消除左递归.png]]  
![[消除左递归-1.png]]  

- 对于当前循环下的主角，考察是否有 $主角\rightarrow 前主角\alpha$ 这样的形式  
	- 没有的话，就对 主角 进行消除直接左递归  
	- 有的话，就把 前主角 的 直接派生 带入进来进行替换（也就是消除直接左递归的第二步不用带入替换） ,然后消除直接左递归，然后对另一个 前主角进行相同的操作  
### 例子：完全分析复杂左递归  
- 如果遇到文法不是直接左递归的，它可能是间接左递归的，或者二者兼具，我们就无法直接使用上述公式来消除其左递归。但我们可以证明，对于一个不含有 $P→P$ 这样的"回路产生式"以及 $P→ε$ 这样的空产生式的文法，我们是一定可以消除其左递归的。我们给出两个这样的文法示例：

#### 例子1
```
G[S]:
S→Qc|c
Q→Rb|b
R→Sa|a
```

- 对于文法G[S]，其每一个产生式都不含有直接左递归，但如果细细察看，它是存在这样的情况的：S→Qc→Rbc→Sabc，也就是间接左递归。对于这样的文法，我们如何消除其左递归。我们先以G[S]为例，叙述其具体消除过程，最后给出普适算法。
	1. 首先给文法的所有非终结符，以任意次序标号，从左向右考察这些非终结符，对于序号为i的非终结符，我们检测它是否有形如 $P _i →P _{i-k} ​α$ 这样的产生式，如果有就将 $P_{i-k}​$ 的出现用其产生式代替。然后消除直接左递归(如果并没有直接左递归就什么也不做).  
	2. 对于G[S]中的非终结符，S、Q、R我们规定一个次序，不妨就是S、Q、R这一次序。首先考察S，它并没有前置位的非终结符，所以我们进入直接左递归消除阶段，发现也没有直接左递归，所以对于S的产生式什么也不做；
	3. 考察Q，它的前置位非终结符是S，但显然Q没有形如Q→Sα这样的产生式，所以进入消除直接左递归的阶段，发现也没有直接左递归，所以对于Q的产生式我们什么也不做；
	4. 考察R，它的前置位非终结符是S和Q。依旧是从左向右考察，第一次扫描是S，我们发现有R→Sa这一产生式，所以执行替换，替换后的产生式为R→Qca|ca|a，进入消除直接左递归阶段，发现并没有事情可做；于是进入下一次扫描，这次的非终结符为Q，现在的R产生式中已经有了R→Qca这一产生式，所以也需要执行替换，替换后的产生式为R→Rbca|bca|ca|a，接下来进入消除左递归阶段，最终我们得到的文法如下所示：
```
G[S]:
S→Qc|c
Q→Rb|b
R→bcaT|caT|aT
T→bcaT|ε
```

#### 例子2  
```
G[L]:
L→La|Tb|c
T→L+|T*|f 
```
1. 我们不妨标记次序为T、L；首先考察T，它并没有前置位非终结符，所以直接进行直接左递归的消除，消除之后的T产生式如下：
```
T→L+M|fM
M→*M|ε
```
2. 考察非终结符L，其前置位非终结符为T，并且L产生式中有L→Tb，所以需要进行替换，替换后的L产生式如下：
```
L→La|L+Mb|fMb|c
```
3. 而后进入左递归消除阶段，消除直接左递归后的L产生式如下：
```
L→fMbN|cN
N→+MbN|aN|ε
```
4.  所以最终得到的无左递归文法如下所示：
```
G[L]:
L→fMbN|cN
N→+MbN|aN|ε
T→L+M|fM
M→*M|ε

显然我们发现,从起始符号L出发,是无法到达非终结符T的,所以关于T的产生式是多余的.
最终:

G[L]:
L→fMbN|cN
N→+MbN|aN|ε
M→*M|ε
```
