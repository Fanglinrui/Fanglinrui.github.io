---
tags:
  - JVM
  - GC
updateTime: 2025-04-11 16:48
---
以下是关于 **JVM 垃圾回收（GC）机制** 的详细介绍，包括主流垃圾收集器及其适用场景和推荐的 JDK 版本：

---

### **一、GC 核心机制**
JVM 的垃圾回收机制基于 **分代收集理论**，将堆内存划分为不同的区域（新生代、老年代），采用不同的算法回收不同区域的对象。

#### 1. **分代模型**
- **新生代（Young Generation）**：存放生命周期短的对象，采用 **复制算法**（如 Serial、ParNew、Parallel Scavenge）。
- **老年代（Old Generation）**：存放长期存活的对象，采用 **标记-整理** 或 **标记-清除** 算法（如 CMS、G1、ZGC）。

#### 2. **GC 触发条件**
- **Minor GC**：新生代空间不足时触发。
- **Major GC/Full GC**：老年代空间不足或元空间不足时触发，通常伴随 Stop-The-World（STW）。

---

### **二、主流垃圾收集器**
以下是 JVM 中常见的垃圾收集器及其特点：

| **收集器**                | **算法**                  | **适用区域**  | **特点**                                                     | **适用场景**         | **推荐 JDK 版本**     |
| ---------------------- | ----------------------- | --------- | ---------------------------------------------------------- | ---------------- | ----------------- |
| **Serial**             | 复制算法（新生代）<br>标记-整理（老年代） | 新生代 + 老年代 | 单线程，STW 时间长                                                | 单核客户端应用          | JDK 1.3+（已过时）     |
| **ParNew**             | 复制算法（新生代）               | 新生代       | Serial 的多线程版本，需与 CMS 配合                                    | 多核服务端            | JDK 1.4~8（旧版本）    |
| **Parallel Scavenge**  | 复制算法（新生代）<br>标记-整理（老年代） | 新生代 + 老年代 | 多线程，关注 **吞吐量优先**（`-XX:MaxGCPauseMillis`、`-XX:GCTimeRatio`） | 计算密集型应用（如批处理）    | JDK 1.4~17（逐步淘汰）  |
| **CMS**                | 标记-清除（老年代）              | 老年代       | 并发收集，减少 STW 时间，但内存碎片多                                      | 低延迟 Web 服务       | JDK 1.5~8（已废弃）    |
| **G1 (Garbage-First)** | 分区算法（Region）            | 全堆        | 平衡吞吐量和延迟，可预测停顿时间（`-XX:MaxGCPauseMillis`）                   | 通用场景（默认收集器）      | **JDK 9+（默认）**    |
| **ZGC**                | 染色指针 + 读屏障              | 全堆        | 超低延迟（STW < 10ms），支持 TB 级堆                                  | 大内存、低延迟应用（如实时系统） | **JDK 11+（生产可用）** |
| **Shenandoah**         | 转发指针 + 读屏障              | 全堆        | 类似 ZGC，但实现更简单，社区驱动                                         | 低延迟应用            | **JDK 12+（生产可用）** |
| **Epsilon**            | 无 GC                    | -         | 仅分配内存，不回收（用于性能测试或短生命周期任务）                                  | 测试、极短生命周期应用      | JDK 11+           |

---

### **三、收集器对比与推荐**
#### 1. **按场景推荐**
- **高吞吐量**：`Parallel Scavenge`（JDK 8 及之前）或 `G1`（JDK 9+）。
- **低延迟**：`G1`（默认）、`ZGC`（大堆）、`Shenandoah`（中小堆）。
- **超大堆（TB 级）**：`ZGC` 或 `Shenandoah`。
- **测试/极短任务**：`Epsilon`。

#### 2. **按 JDK 版本推荐**
- **JDK 8**：
  - 默认：Parallel Scavenge（新生代） + Parallel Old（老年代）。
  - 低延迟：手动启用 `CMS`（但已废弃，不推荐新项目使用）。
- **JDK 11~16**：
  - 默认：`G1`。
  - 可选：`ZGC`（需 `-XX:+UseZGC`）、`Shenandoah`（需 `-XX:+UseShenandoahGC`）。
- **JDK 17+**：
  - 默认：`G1`。
  - 生产推荐：`ZGC`（成熟稳定）、`Shenandoah`（社区支持）。

---

### **四、GC 调优核心参数**
| **参数**                          | **作用**                               | **示例**                     |
|-----------------------------------|----------------------------------------|------------------------------|
| `-XX:+UseG1GC`                    | 启用 G1 收集器                         | JDK 9+ 默认                  |
| `-XX:+UseZGC`                     | 启用 ZGC                               | JDK 11+                      |
| `-XX:+UseShenandoahGC`            | 启用 Shenandoah                        | JDK 12+                      |
| `-Xmx` / `-Xms`                   | 设置堆最大/初始大小                    | `-Xmx4G -Xms4G`              |
| `-XX:MaxGCPauseMillis`            | 目标最大停顿时间（G1/ZGC/Shenandoah）  | `-XX:MaxGCPauseMillis=200`   |
| `-XX:MetaspaceSize` / `-XX:MaxMetaspaceSize` | 设置元空间大小             | `-XX:MaxMetaspaceSize=256M`  |
| `-XX:MaxDirectMemorySize`         | 限制直接内存大小                       | `-XX:MaxDirectMemorySize=1G` |

---

### **五、总结**
- **JDK 8 及之前**：优先使用 `Parallel Scavenge`（高吞吐量）或 `G1`（低延迟）。
- **JDK 11+**：默认 `G1`，推荐 `ZGC` 或 `Shenandoah` 以追求亚毫秒级停顿。
- **超大堆或极致低延迟**：选择 `ZGC`（Oracle 官方支持）或 `Shenandoah`（Red Hat 社区驱动）。
- **升级建议**：优先升级到 JDK 17+，充分利用现代收集器的优势（如 ZGC 的弹性堆和亚毫秒级 STW）。

通过合理选择垃圾收集器并结合调优参数，可以显著提升 Java 应用的性能和稳定性。