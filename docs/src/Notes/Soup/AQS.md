---
tags:
  - JUC
  - AQS
---
## 速览
以下是关于 **AQS（AbstractQueuedSynchronizer）** 的总结：

1. **定义与核心思想**:
   - AQS 是 Java 并发工具的重要基础框架，通过 **state** 变量和 **同步队列** 实现线程的同步和排队。
   - 提供 **独占模式** 和 **共享模式** 两种线程访问模式。

2. **核心功能**:
   - **独占模式**：一个线程独占资源（如 `ReentrantLock`）。
   - **共享模式**：多个线程可同时访问资源（如 `CountDownLatch` 和 `Semaphore`）。

3. **重要方法**:
   - 独占模式：`acquire` 和 `release`。
   - 共享模式：`acquireShared` 和 `releaseShared`。
   - 条件变量支持：通过 `ConditionObject` 实现线程的等待和唤醒。

4. **典型应用**:
   - `ReentrantLock`: 使用独占模式构建，可重入锁。
   - `CountDownLatch`: 倒计时器，允许多个线程等待计数器归零。
   - `Semaphore`: 信号量，限制同时访问某资源的线程数量。

5. **关键数据结构**:
   - **同步队列**：FIFO 的双向链表，保存阻塞的线程。
   - **Condition 队列**：支持条件等待的线程管理。

6. **工作流程概述**:
   - **获取资源**：线程尝试通过 CAS 操作修改 `state`，失败则进入同步队列等待。
   - **释放资源**：更新 `state` 并唤醒队列中的线程。

7. **优点与挑战**:
   - **优点**：统一的架构，提升了代码复用率与性能。
   - **挑战**：实现复杂，操作不当可能引发同步问题。

AQS 是 Java 并发工具的核心，通过其统一的设计和高性能实现，简化了构建复杂同步工具的难度。


## 详解
AQS 是 AbstractQueuedSynchronizer 的简称，是 Java 并发编程中非常重要的一个工具类。它是 Java.util.concurrent 包下的一个核心组件，用于构建锁（Lock）、同步器（如 CountDownLatch、Semaphore）、线程池等。

### 1. **基本架构**
AQS 以 **volatile 类型的整型变量 `state`** 作为核心，同步状态的改变需要依赖线程安全的 CAS 操作。主要组成包括：
- **同步队列**：是一个 FIFO 的双向链表，所有获取锁失败的线程都会加入队列。
- **Condition 队列**：通过 `ConditionObject` 实现，保存了因 `await` 方法进入等待的线程。

### 2. **工作模式**
AQS 提供了两种模式的实现：
- **独占模式（Exclusive Mode）**：只有一个线程能占有资源。例如 `ReentrantLock`。
- **共享模式（Shared Mode）**：多个线程可以共享资源。例如 `Semaphore` 和 `CountDownLatch`。

### 3. **核心方法**
以下是 AQS 的核心方法，它们通过子类来进行实现：
#### 独占模式方法：
- **acquire(int arg)**：尝试获取资源，失败则将线程放入同步队列中，进入等待状态。
- **release(int arg)**：释放资源，并唤醒同步队列中的后继线程。

#### 共享模式方法：
- **acquireShared(int arg)**：尝试以共享模式获取资源，如果失败则进入队列等待。
- **releaseShared(int arg)**：共享模式下的资源释放，唤醒其他在队列中的线程。

### 4. **同步队列的实现**
同步队列是 AQS 的核心数据结构，它是一个双向链表，节点为 `Node`：
- 每个节点代表一个线程。
- 节点分为两类：**独占模式节点 (EXCLUSIVE)** 和 **共享模式节点 (SHARED)**。
- `CLH锁` 的思想：每个线程通过自旋等待前驱节点的状态。

### 5. **流程解析**
以下是独占模式的获取和释放资源的具体流程：
#### (1) 获取资源：
1. 调用 `acquire()` 方法；
2. 在 `tryAcquire()` 方法中尝试获取资源，成功则直接返回；
3. 失败时，将线程加入同步队列；
4. 在线程被唤醒前，节点会处于自旋等待状态。

#### (2) 释放资源：
1. 调用 `release()` 方法；
2. 更新同步状态；
3. 如果资源状态为可用，则唤醒同步队列中的后继线程。

### 6. **Condition 的实现**
`ConditionObject` 是 AQS 提供的一个内部类，用来支持条件变量：
- 线程通过调用 `await()` 方法进入等待队列。
- 条件满足时，调用 `signal()` 方法，将等待队列的线程转移到同步队列中。

### 7. **优势与不足**
#### **优势：**
- AQS 为同步器的实现提供了统一的架构，大大提高了代码复用率；
- 支持多种复杂同步器（如锁、信号量、栅栏）；
- 高性能：大量采用 CAS 和自旋来减少线程的阻塞。

#### **不足：**
- 实现相对复杂，需要较高的学习成本；
- 直接操作队列和状态位，可能导致 bug，需谨慎开发。
