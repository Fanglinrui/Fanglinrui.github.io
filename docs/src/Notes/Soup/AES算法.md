---
tags:
  - AES算法
  - "#有限域"
  - "#欧几里得算法"
来自于: https://bbs.kanxue.com/thread-253884.htm
参考: "[[深入浅出密码学——常见加密技术原理与应用 (Chris_ (Z-Library).pdf]]"
是否完成: false
是否归档: false
---
# 1 AES相关数学知识  
*在AES的列混合运算中运用了伽罗瓦域中的乘法运算*  
## 1.1有限域
* 研究的是有限域，也就是其中元素个数有限  
* 域中元素个数是 *素数幂* 时，域才存在。此时，个数称为阶、素数（不是素数幂）称为特征  
* GF(2)是非常重要的一个素域，也是最小的有限域
## 1.2扩展域  
* 当特征的次数大于1时，称之为扩展域  
* 比如$GF(2^n)$   
* 其中的元素是以系数为GF(2)中的元素的多项式表示
* 多项式的最大次数为n-1
* AES使用的是$GF(2^8)$ 
	* 每个元素$A \in GF(2^8)$，都有：
	* $A(x)=a_7x^7+a_6x^6+...+a_1x+a_0 ,a_i\in GF(2)=0,1$ 
	* TIPS：括号内的内容也称为阶，是个数；这有256个  
### 1.2.1 扩展域中的加减法  
* 一句话概括：**对相同次数的项的系数做*模2加法（也可以是异或操作）*** ，不进位  
* $C(x)=A(x)\pm B(x)=\sum\limits^{m-1}_{i=0}C_ix^i,c_i \equiv (a_i+b_i)\mod2$   
## 1.2.2 扩展域中的乘法  
* 用在AES的列混淆层  
* *进行多项式乘法：*   
$A(x)\cdot B(x) = (a_{m-1}x^{m-1}+...+a_0)\cdot(b_{m-1}x^{m-1}+...+b_0)$ 
$C'(x)=c'_{2m-2}x^{2m-2}+...+c'_0$  
 
* 注意事项：
	* 所得的C(x)的度大于n-1，因此要化简，具体来说就是用它去除以一个**不可约多项式**  ，取余式
	* 也就是说  
	* $C(x)\equiv A(x)\cdot B(x) \mod P(x)$  
	* AES中使用的不可约多项式P(x)是：
	* $P(x)=x^8+x^4+x^3+x+1$

* 一条例子如图  
![[AES算法.png]]
* 图中的小瑕疵：同次数的对其方便看
* 注意，加法减法是一样的  

# 2 AES算法原理  
## 2.1 综述  
* 是SPN结构 区别于Feistel结构
* 密钥，明文均为16B, 按照从上到下，从左到右排列成一个4x4方阵，如下：

| 1   | 5   | 9   | 13  |
| --- | --- | --- | --- |
| **2**   | **6**   | **10**  | **14**  |
| **3**   | **7**   | **11**  | **15**  |
| **4**   | **8**   | **12**  | **16**  |
* 每一轮（除了最后一轮），均按顺序经过：
	* 字节代换层  
	* 扩散层：分别是行位移层，列混淆层  
	* 密钥加法层
* 最后一轮没有列混淆  
![[AES算法-4.png]]
## 2.2 各层介绍  
### 2.2.1 字节代换层  
* 本层重点：S_box
* 输入：一个4阶方阵
* 输出：一个4阶方阵  
* 运算过程：查表，高四位为行号，低四位为列号
### 2.2.2 扩散层  
#### 2.2.2.1 行位移
* 第一行不变，第二行左移1格，第三行左移2格，第四行左移3格  
* 位移后的结果：

| **1**  | **5**  | **9**  | **13** |
| ------ | ------ | ------ | ------ |
| **6**  | **10** | **14** | **2**  |
| **11** | **15** | **3**  | **7**  |
| **16** | **4**  | **8**  | **12** |
#### 2.2.2.2 列混淆  
**非常重要**   
* 使得每一个输入的“格子”（字节），都可以影响四个输出字节。
* 正向列混淆中，需要将输入的矩阵右乘一个给定的4阶方阵，运算在扩展域$GF(2^8)$中进行（左边的是给定的矩阵，右边的是输入）
* 其中的一列如下：
![[AES算法-1.png]]  
* 向量矩阵乘法中的加法也是GF(2)中的加法，即对应字节进行简单的按位XOR操作。为了实现常量的乘法，首先需要实现与常量01、02和03的乘法。这个做法的效率非常高，实际中这三个常量通常会选择易于软件实现的数值。与01的乘法就是与单位元的乘法，并没有涉及其他显式操作。与02和03的乘法则是通过查找两个256乘8的表完成的。计算与02的乘法的另一种方法就是先**与x相乘即向左移动一位，再与P(x)=x^8+x^4+x^3+x+1进行模约简**。同样，与03(表示的多项式为x+1)的乘法可以通过**先左移一位，再与原来的值相加，最后与P(x)进行模约简得到**。
### 2.2.3 密钥加法层  
* 正如它的名字，是与密钥进行异或（按位）  
* 在进行第一轮前，会先进行一次与k0的加法层运算。  
## 2.3 密钥生成  
![[AES算法-2.png]]  
要点：  
* 最左边一列的`w[4i] = w[4(i-1)] + G(w[4i-1])`,也就是它本身的上一代加上最后一列经过**G函数**的结果
* 其他的列`w[4i+j] = w[4(i-1)+j] + w[4i-1+j]`，也就是它本身上一代加上上一个（不是上一代）
* 注意，G函数中还有一个轮系数如下：
![[AES算法-3.png]]    
## 2.4 解密过程  
![[AES算法-6.png]]  
# 3 进阶知识  
## 3.1*关于S盒的生成，以及扩展欧几里得算法，待施工*    
* 手动算多项式的逆方法如下  
![[AES算法-9.jpg]]
## 3.2 快速计算乘法  
![[AES算法-7.png]]  
* 第二种情况相当于8次多项式减去（异或）不可约多项式  
* 一个例子如下：  
![[AES算法-8.png|一个例子]]  
